// Code generated by goagen v1.3.0, DO NOT EDIT.
//
// API "MoneyForest": Application User Types
//
// Command:
// $ goagen
// --design=github.com/odiak/MoneyForest/design
// --out=$(GOPATH)/src/github.com/odiak/MoneyForest
// --version=v1.3.0

package app

import (
	"github.com/goadesign/goa"
	uuid "github.com/satori/go.uuid"
	"unicode/utf8"
)

// accountPayload user type.
type accountPayload struct {
	AccountType *string `form:"accountType,omitempty" json:"accountType,omitempty" xml:"accountType,omitempty"`
	Balance     *int    `form:"balance,omitempty" json:"balance,omitempty" xml:"balance,omitempty"`
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	HasBalance  *bool   `form:"hasBalance,omitempty" json:"hasBalance,omitempty" xml:"hasBalance,omitempty"`
	Name        *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
}

// Finalize sets the default values for accountPayload type instance.
func (ut *accountPayload) Finalize() {
	var defaultBalance = 0
	if ut.Balance == nil {
		ut.Balance = &defaultBalance
	}
	var defaultDescription = ""
	if ut.Description == nil {
		ut.Description = &defaultDescription
	}
	var defaultHasBalance = false
	if ut.HasBalance == nil {
		ut.HasBalance = &defaultHasBalance
	}
}

// Validate validates the accountPayload type instance.
func (ut *accountPayload) Validate() (err error) {
	if ut.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "name"))
	}
	if ut.Description == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "description"))
	}
	if ut.AccountType == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "accountType"))
	}
	if ut.HasBalance == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "hasBalance"))
	}
	if ut.Balance == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "balance"))
	}
	if ut.AccountType != nil {
		if !(*ut.AccountType == "wallet" || *ut.AccountType == "bank" || *ut.AccountType == "credit-card") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.accountType`, *ut.AccountType, []interface{}{"wallet", "bank", "credit-card"}))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	return
}

// Publicize creates AccountPayload from accountPayload
func (ut *accountPayload) Publicize() *AccountPayload {
	var pub AccountPayload
	if ut.AccountType != nil {
		pub.AccountType = *ut.AccountType
	}
	if ut.Balance != nil {
		pub.Balance = *ut.Balance
	}
	if ut.Description != nil {
		pub.Description = *ut.Description
	}
	if ut.HasBalance != nil {
		pub.HasBalance = *ut.HasBalance
	}
	if ut.Name != nil {
		pub.Name = *ut.Name
	}
	return &pub
}

// AccountPayload user type.
type AccountPayload struct {
	AccountType string `form:"accountType" json:"accountType" xml:"accountType"`
	Balance     int    `form:"balance" json:"balance" xml:"balance"`
	Description string `form:"description" json:"description" xml:"description"`
	HasBalance  bool   `form:"hasBalance" json:"hasBalance" xml:"hasBalance"`
	Name        string `form:"name" json:"name" xml:"name"`
}

// Validate validates the AccountPayload type instance.
func (ut *AccountPayload) Validate() (err error) {
	if ut.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "name"))
	}
	if ut.Description == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "description"))
	}
	if ut.AccountType == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "accountType"))
	}

	if !(ut.AccountType == "wallet" || ut.AccountType == "bank" || ut.AccountType == "credit-card") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.accountType`, ut.AccountType, []interface{}{"wallet", "bank", "credit-card"}))
	}
	if utf8.RuneCountInString(ut.Name) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.name`, ut.Name, utf8.RuneCountInString(ut.Name), 1, true))
	}
	return
}

// categoryPayload user type.
type categoryPayload struct {
	Name             *string    `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	ParentCategoryID *uuid.UUID `form:"parentCategoryId,omitempty" json:"parentCategoryId,omitempty" xml:"parentCategoryId,omitempty"`
}

// Validate validates the categoryPayload type instance.
func (ut *categoryPayload) Validate() (err error) {
	if ut.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "name"))
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	return
}

// Publicize creates CategoryPayload from categoryPayload
func (ut *categoryPayload) Publicize() *CategoryPayload {
	var pub CategoryPayload
	if ut.Name != nil {
		pub.Name = *ut.Name
	}
	if ut.ParentCategoryID != nil {
		pub.ParentCategoryID = ut.ParentCategoryID
	}
	return &pub
}

// CategoryPayload user type.
type CategoryPayload struct {
	Name             string     `form:"name" json:"name" xml:"name"`
	ParentCategoryID *uuid.UUID `form:"parentCategoryId,omitempty" json:"parentCategoryId,omitempty" xml:"parentCategoryId,omitempty"`
}

// Validate validates the CategoryPayload type instance.
func (ut *CategoryPayload) Validate() (err error) {
	if ut.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "name"))
	}
	if utf8.RuneCountInString(ut.Name) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.name`, ut.Name, utf8.RuneCountInString(ut.Name), 1, true))
	}
	return
}

// transactionPayload user type.
type transactionPayload struct {
	AccountID       *uuid.UUID `form:"accountId,omitempty" json:"accountId,omitempty" xml:"accountId,omitempty"`
	Amount          *int       `form:"amount,omitempty" json:"amount,omitempty" xml:"amount,omitempty"`
	CategoryID      *uuid.UUID `form:"categoryId,omitempty" json:"categoryId,omitempty" xml:"categoryId,omitempty"`
	Date            *string    `form:"date,omitempty" json:"date,omitempty" xml:"date,omitempty"`
	Description     *string    `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	OriginalTitle   *string    `form:"originalTitle,omitempty" json:"originalTitle,omitempty" xml:"originalTitle,omitempty"`
	Title           *string    `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	TransactionType *string    `form:"transactionType,omitempty" json:"transactionType,omitempty" xml:"transactionType,omitempty"`
}

// Finalize sets the default values for transactionPayload type instance.
func (ut *transactionPayload) Finalize() {
	var defaultDescription = ""
	if ut.Description == nil {
		ut.Description = &defaultDescription
	}
	var defaultOriginalTitle = ""
	if ut.OriginalTitle == nil {
		ut.OriginalTitle = &defaultOriginalTitle
	}
}

// Validate validates the transactionPayload type instance.
func (ut *transactionPayload) Validate() (err error) {
	if ut.AccountID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "accountId"))
	}
	if ut.Amount == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "amount"))
	}
	if ut.TransactionType == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "transactionType"))
	}
	if ut.Title == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "title"))
	}
	if ut.Date == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "date"))
	}
	if ut.Date != nil {
		if ok := goa.ValidatePattern(`^\d{1,4}-\d{2}-\d{2}$`, *ut.Date); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`request.date`, *ut.Date, `^\d{1,4}-\d{2}-\d{2}$`))
		}
	}
	if ut.TransactionType != nil {
		if !(*ut.TransactionType == "expense" || *ut.TransactionType == "income" || *ut.TransactionType == "transfer" || *ut.TransactionType == "balance-adjustment") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.transactionType`, *ut.TransactionType, []interface{}{"expense", "income", "transfer", "balance-adjustment"}))
		}
	}
	return
}

// Publicize creates TransactionPayload from transactionPayload
func (ut *transactionPayload) Publicize() *TransactionPayload {
	var pub TransactionPayload
	if ut.AccountID != nil {
		pub.AccountID = *ut.AccountID
	}
	if ut.Amount != nil {
		pub.Amount = *ut.Amount
	}
	if ut.CategoryID != nil {
		pub.CategoryID = ut.CategoryID
	}
	if ut.Date != nil {
		pub.Date = *ut.Date
	}
	if ut.Description != nil {
		pub.Description = *ut.Description
	}
	if ut.OriginalTitle != nil {
		pub.OriginalTitle = *ut.OriginalTitle
	}
	if ut.Title != nil {
		pub.Title = *ut.Title
	}
	if ut.TransactionType != nil {
		pub.TransactionType = *ut.TransactionType
	}
	return &pub
}

// TransactionPayload user type.
type TransactionPayload struct {
	AccountID       uuid.UUID  `form:"accountId" json:"accountId" xml:"accountId"`
	Amount          int        `form:"amount" json:"amount" xml:"amount"`
	CategoryID      *uuid.UUID `form:"categoryId,omitempty" json:"categoryId,omitempty" xml:"categoryId,omitempty"`
	Date            string     `form:"date" json:"date" xml:"date"`
	Description     string     `form:"description" json:"description" xml:"description"`
	OriginalTitle   string     `form:"originalTitle" json:"originalTitle" xml:"originalTitle"`
	Title           string     `form:"title" json:"title" xml:"title"`
	TransactionType string     `form:"transactionType" json:"transactionType" xml:"transactionType"`
}

// Validate validates the TransactionPayload type instance.
func (ut *TransactionPayload) Validate() (err error) {

	if ut.TransactionType == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "transactionType"))
	}
	if ut.Title == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "title"))
	}
	if ut.Date == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "date"))
	}
	if ok := goa.ValidatePattern(`^\d{1,4}-\d{2}-\d{2}$`, ut.Date); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`type.date`, ut.Date, `^\d{1,4}-\d{2}-\d{2}$`))
	}
	if !(ut.TransactionType == "expense" || ut.TransactionType == "income" || ut.TransactionType == "transfer" || ut.TransactionType == "balance-adjustment") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.transactionType`, ut.TransactionType, []interface{}{"expense", "income", "transfer", "balance-adjustment"}))
	}
	return
}

// userPayload user type.
type userPayload struct {
	Email    *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	Name     *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	Password *string `form:"password,omitempty" json:"password,omitempty" xml:"password,omitempty"`
}

// Validate validates the userPayload type instance.
func (ut *userPayload) Validate() (err error) {
	if ut.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "name"))
	}
	if ut.Email == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "email"))
	}
	if ut.Password == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "password"))
	}
	if ut.Email != nil {
		if err2 := goa.ValidateFormat(goa.FormatEmail, *ut.Email); err2 != nil {
			err = goa.MergeErrors(err, goa.InvalidFormatError(`request.email`, *ut.Email, goa.FormatEmail, err2))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 2 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 2, true))
		}
	}
	if ut.Password != nil {
		if utf8.RuneCountInString(*ut.Password) < 8 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.password`, *ut.Password, utf8.RuneCountInString(*ut.Password), 8, true))
		}
	}
	return
}

// Publicize creates UserPayload from userPayload
func (ut *userPayload) Publicize() *UserPayload {
	var pub UserPayload
	if ut.Email != nil {
		pub.Email = *ut.Email
	}
	if ut.Name != nil {
		pub.Name = *ut.Name
	}
	if ut.Password != nil {
		pub.Password = *ut.Password
	}
	return &pub
}

// UserPayload user type.
type UserPayload struct {
	Email    string `form:"email" json:"email" xml:"email"`
	Name     string `form:"name" json:"name" xml:"name"`
	Password string `form:"password" json:"password" xml:"password"`
}

// Validate validates the UserPayload type instance.
func (ut *UserPayload) Validate() (err error) {
	if ut.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "name"))
	}
	if ut.Email == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "email"))
	}
	if ut.Password == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "password"))
	}
	if err2 := goa.ValidateFormat(goa.FormatEmail, ut.Email); err2 != nil {
		err = goa.MergeErrors(err, goa.InvalidFormatError(`type.email`, ut.Email, goa.FormatEmail, err2))
	}
	if utf8.RuneCountInString(ut.Name) < 2 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.name`, ut.Name, utf8.RuneCountInString(ut.Name), 2, true))
	}
	if utf8.RuneCountInString(ut.Password) < 8 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.password`, ut.Password, utf8.RuneCountInString(ut.Password), 8, true))
	}
	return
}
